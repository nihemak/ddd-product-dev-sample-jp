# 開発ガイドライン

このドキュメントは、本プロジェクトにおける開発プロセス、ドキュメントの役割、およびシームレスな連携を維持するためのガイドラインを定めます。

## 開発の全体像

本プロジェクトでは、ドメイン駆動設計 (DDD) の考え方に基づき、要求定義から実装までを以下の流れで進めることを推奨します。

1.  **要求・仕様の探求**: ドメインエキスパート（もしいる場合）や関係者と共に、ビジネス要求を深く理解します。イベントストーミングやユーザーストーリーマッピングなどの手法を活用し、主要なドメインイベント、コマンド、アクター、重要な概念を洗い出します。
    *   **成果物**: `docs/requirements/` 以下にMarkdownなどで記録します。

2.  **ドメインモデリングとユビキタス言語の定義**: 要求探求で得られた知見に基づき、ドメインモデル（エンティティ、値オブジェクト、集約など）を設計し、それらを表現するための**ユビキタス言語**を定義・洗練させます。
    *   **成果物**:
        *   `docs/domain/ubiquitous-language.md`: ユビキタス言語集（最重要）
        *   `docs/domain/domain-model.md`: ドメインモデル図 (Mermaid)

3.  **アーキテクチャ設計**: オニオンアーキテクチャの原則に従い、各レイヤー（Domain, Application, Infrastructure）の責務を明確にし、依存関係を定義します。重要な技術選定や設計判断は ADR (Architecture Decision Record) として記録します。
    *   **成果物**:
        *   `docs/architecture/overview.md`: アーキテクチャ概要
        *   `docs/architecture/adr/`: ADR

4.  **実装 (テスト駆動開発 - TDD)**: ユビキタス言語とドメインモデルに基づき、テストファーストで実装を進めます。
    *   **Domain層**: ドメインロジックを純粋関数として実装し、単体テストで検証します。
    *   **Application層**: ユースケースを実装します。リポジトリ等の依存性はモック化し、テストします (`mockall` 活用)。
    *   **Infrastructure層**: リポジトリインターフェースを実装します。必要に応じて結合テストを行います。
    *   **コード**: `src/` 以下。
    *   **テスト**: 各モジュール内の `#[cfg(test)] mod tests { ... }`。

5.  **レビューとフィードバック**: Pull Request を通じてコードレビューを実施します。コードだけでなく、ユビキタス言語の一貫性、ドキュメントの更新もレビュー対象とします。

6.  **継続的な改善**: 実装を進める中で得られた新たな知見に基づき、ユビキタス言語、ドメインモデル、ドキュメントを継続的に改善します。

## ドキュメントの役割と連携

`docs/` ディレクトリ内のドキュメントは、コードと並んでプロジェクトの重要な構成要素です。常に最新の状態を保ち、コードとの一貫性を維持することが求められます。

*   **`docs/requirements/`**: なぜこのソフトウェアを作るのか、どのような問題を解決するのか、という要求の根源を記録します。ユビキタス言語やドメインモデルのインプットとなります。
*   **`docs/domain/ubiquitous-language.md`**: プロジェクトにおける**共通言語**の辞書です。すべてのコミュニケーション（会話、コード、テスト、ドキュメント）はこの言語に基づいて行われます。機能追加や変更時には、まずこのドキュメントを更新・参照します。
*   **`docs/domain/domain-model.md`**: ユビキタス言語で定義された概念間の関係性を視覚的に表現します。複雑なドメイン構造の理解を助け、設計の議論を促進します。コード (`src/domain.rs`) の構造と対応している必要があります。
*   **`docs/architecture/overview.md`**: プロジェクト全体の構造、レイヤー間の依存関係ルールを示します。新しい開発者がプロジェクトの全体像を把握するために役立ちます。
*   **`docs/architecture/adr/`**: なぜ特定の技術や設計パターンを採用したのか、その背景やトレードオフを記録します。将来の変更時に過去の意思決定を理解するのに役立ちます。
*   **`README.md`**: プロジェクトへの入り口です。概要、セットアップ方法、主要なドキュメントへのリンクを提供します。
*   **ソースコード (`src/`)**: 実行可能な仕様そのものです。特に `src/domain.rs` は、ドメインルールとロジックの最も正確な表現です。
    *   **ドキュメントコメント (`///`)**: `cargo doc` で生成されるドキュメント。公開APIの利用方法や目的を説明します。
    *   **テストコード (`#[test]`)**: 具体的な利用例や仕様を示します。

### シームレスな連携のためのプラクティス

*   **ユビキタス言語の徹底**: コードを書く前、会話する際、ドキュメントを作成する際に、常に `ubiquitous-language.md` を参照・意識します。レビューでは用語の不一致を指摘します。
*   **コードとドキュメントの同期**: コード変更（特にドメイン層やインターフェース）と同時に、関連するドキュメント（ユビキタス言語、モデル図）も更新します。Pull Request にドキュメント変更も含めることを原則とします。
*   **軽量ドキュメント**: PlantUML/Mermaid や ADR など、テキストベースでバージョン管理しやすく、メンテナンスコストの低い形式を優先します。
*   **レビューの活用**: コードレビュー時に、関連ドキュメントとの整合性も確認します。

## ツールの活用

*   **Mermaid**: `domain-model.md` や `overview.md` 内で図を描画します。Cursor (VS Code) のプレビュー機能で確認できます。
*   **`cargo test`**: 実装したコードが仕様（テストケース）を満たしているかを確認します。コミット前には必ず実行します。
*   **`cargo fmt`**: コードスタイルを統一します。コミット前に実行します。
*   **`cargo clippy`**: 静的解析により、潜在的な問題や改善点を指摘します。定期的に実行します。
*   **`cargo doc`**: ソースコード中のドキュメントコメントからHTMLドキュメントを生成します。
*   **Git**: バージョン管理。コミットメッセージは **Conventional Commits** 規約に従います。
    *   **フォーマット**: `<type>(<scope>): <subject>`
        *   `type`: コミットの種類 (例: `feat`, `fix`, `docs`, `style`, `refactor`, `test`, `chore`)。
        *   `scope` (任意): コミットが影響する範囲 (例: `domain`, `application`, `readme`)。
        *   `subject`: 変更内容の簡潔な説明（**日本語で記述**）。50文字以内が目安。
    *   **例**:
        *   `feat(注文): 注文キャンセル機能を追加`
        *   `fix(domain): 価格計算時のオーバーフローを修正 (#123)`
        *   `docs: DEVELOPMENT_GUIDE にコミット規約を追記`
        *   `refactor: 注文サービスの依存性注入方法を変更`
        *   `test(application): 注文受付サービスのテストケースを追加`
    *   詳細は [Conventional Commits](https://www.conventionalcommits.org/) を参照してください。
    *   コミット前に `cargo fmt` を実行し、コードがフォーマットされていることを確認します。
