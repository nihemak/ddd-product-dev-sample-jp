# 開発ガイドライン

このドキュメントは、本プロジェクトにおける開発プロセス、ドキュメントの役割、およびシームレスな連携を維持するためのガイドラインを定めます。

## 開発の全体像

本プロジェクトでは、ドメイン駆動設計 (DDD) の考え方に基づき、要求定義から実装までを以下の流れで進めることを推奨します。

1.  **要求・仕様の探求 (イベントストーミングの活用)**:
    *   **目的**: ビジネス要求を深く理解し、ドメインイベント、コマンド、アクター、重要な概念を洗い出す。
    *   **手法**: ドメインエキスパートや関係者と共に**イベントストーミング**を実施します。
        *   (a) ドメインイベント（起こった事実、過去形）をオレンジ色の付箋に書き出し、時間軸に沿って並べます (例: `注文が受け付けられた`, `支払いが行われた`, `商品が発送された`)。
        *   (b) 各イベントのトリガーとなったコマンド（操作、命令形）を青色の付箋に書き、イベントの前に置きます (例: `注文を受け付ける`, `支払いを実行する`, `商品を発送する`)。
        *   (c) コマンドを実行したアクター（人、システム）を黄色の付箋に書き、コマンドの近くに置きます (例: `顧客`, `支払いシステム`, `倉庫担当者`)。
        *   (d) コマンドやイベントに関連するビジネスの中心的なモノ（集約）をピンク色の付箋に書き出します (例: `注文`, `支払い`, `在庫`)。
        *   (e) その他、参照情報（Read Model 例: `商品価格`）、外部システム（例: `配送サービス`）、ルール（Policy 例: `割引適用ルール`）、課題なども必要に応じて書き出します。
    *   **成果物**: イベントストーミングの結果（写真やオンラインボードのリンク、発見された要素リスト、主要ワークフロー、課題など）を `docs/requirements/eventstorming.md` に記録します。ここで発見された用語はユビキタス言語の重要な候補となります。

2.  **ドメインモデリングとユーザーストーリーへの落とし込み (ユーザーストーリーマッピングの活用)**:
    *   **目的**: イベントストーミングで得られた知見を基に、ユーザー視点で機能を整理し、ドメインモデルを設計、ユビキタス言語を定義・洗練させる。
    *   **手法**: **ユーザーストーリーマッピング**を実施します。
        *   (a) ユーザーの主要な活動やタスク（イベントストーミングのアクターの行動などがヒント）を横軸（バックボーン）に並べます。
        *   (b) 各タスクを実現するための具体的な機能（ストーリー）を、イベントストーミングのコマンドやRead Model要求などを参考に洗い出し、バックボーンの下に縦に並べます（エラーケースも含む）。
        *   (c) ストーリーを優先順位に従って並べ替え、リリース計画（MVPなど）を定義します。
    *   **成果物**:
        *   ユーザーストーリーマップの結果（バックボーン、ストーリー、リリース計画）を `docs/requirements/user_story_mapping.md` に記録します。
        *   この過程で明確になった用語とその定義、ルールなどを **`docs/domain/ubiquitous-language.md`** に**最重要ドキュメントとして**集約・更新します。
        *   ユビキタス言語に基づき、主要な集約やエンティティ、値オブジェクトの関係性を `docs/domain/domain-model.md` (Mermaid) で視覚化します。

3.  **アーキテクチャ設計**: オニオンアーキテクチャの原則に従い、各レイヤー（Domain, Application, Infrastructure）の責務を明確にし、依存関係を定義します。重要な技術選定や設計判断は ADR (Architecture Decision Record) として記録します。
    *   **成果物**:
        *   `docs/architecture/overview.md`: アーキテクチャ概要
        *   `docs/architecture/adr/`: ADR

4.  **実装 (テスト駆動開発 - TDD)**: ユビキタス言語、ドメインモデル、ユーザーストーリーに基づき、テストファーストで実装を進めます。
    *   **Domain層**: ドメインロジックを純粋関数として実装し、単体テストで検証します。
    *   **Application層**: ユースケース（ストーリーに対応）を実装します。リポジトリ等の依存性はモック化し、テストします (`mockall` 活用)。
    *   **Infrastructure層**: リポジトリインターフェースを実装します。必要に応じて結合テストを行います。
    *   **コード**: `src/` 以下。
    *   **テスト**: 各モジュール内の `#[cfg(test)] mod tests { ... }`。

5.  **レビューとフィードバック**: Pull Request を通じてコードレビューを実施します。コードだけでなく、ユビキタス言語の一貫性、関連ドキュメント（ストーリー、モデル図など）との整合性、ドキュメントの更新もレビュー対象とします。

6.  **継続的な改善**: 実装を進める中で得られた新たな知見に基づき、要求ドキュメント、ユビキタス言語、ドメインモデル、その他のドキュメントを継続的に改善します。

## ドキュメントの役割と連携

`docs/` ディレクトリ内のドキュメントは、コードと並んでプロジェクトの重要な構成要素です。常に最新の状態を保ち、コードとの一貫性を維持することが求められます。

*   **`docs/requirements/`**: なぜこのソフトウェアを作るのか、どのような問題を解決するのか、という要求の根源を記録します。ユビキタス言語やドメインモデルのインプットとなります。
*   **`docs/domain/ubiquitous-language.md`**: プロジェクトにおける**共通言語**の辞書です。すべてのコミュニケーション（会話、コード、テスト、ドキュメント）はこの言語に基づいて行われます。機能追加や変更時には、まずこのドキュメントを更新・参照します。
*   **`docs/domain/domain-model.md`**: ユビキタス言語で定義された概念間の関係性を視覚的に表現します。複雑なドメイン構造の理解を助け、設計の議論を促進します。コード (`src/domain.rs`) の構造と対応している必要があります。
*   **`docs/architecture/overview.md`**: プロジェクト全体の構造、レイヤー間の依存関係ルールを示します。新しい開発者がプロジェクトの全体像を把握するために役立ちます。
*   **`docs/architecture/adr/`**: なぜ特定の技術や設計パターンを採用したのか、その背景やトレードオフを記録します。将来の変更時に過去の意思決定を理解するのに役立ちます。
*   **`README.md`**: プロジェクトへの入り口です。概要、セットアップ方法、主要なドキュメントへのリンクを提供します。
*   **ソースコード (`src/`)**: 実行可能な仕様そのものです。特に `src/domain.rs` は、ドメインルールとロジックの最も正確な表現です。
    *   **ドキュメントコメント (`///`)**: `cargo doc` で生成されるドキュメント。公開APIの利用方法や目的を説明します。
    *   **テストコード (`#[test]`)**: 具体的な利用例や仕様を示します。

### シームレスな連携のためのプラクティス

*   **ユビキタス言語の徹底**: コードを書く前、会話する際、ドキュメントを作成する際に、常に `ubiquitous-language.md` を参照・意識します。レビューでは用語の不一致を指摘します。
*   **コードとドキュメントの同期**: コード変更（特にドメイン層やインターフェース）と同時に、関連するドキュメント（ユビキタス言語、モデル図）も更新します。Pull Request にドキュメント変更も含めることを原則とします。
*   **軽量ドキュメント**: PlantUML/Mermaid や ADR など、テキストベースでバージョン管理しやすく、メンテナンスコストの低い形式を優先します。
*   **レビューの活用**: コードレビュー時に、関連ドキュメントとの整合性も確認します。

## ツールの活用

*   **Mermaid**: `domain-model.md` や `overview.md` 内で図を描画します。Cursor (VS Code) のプレビュー機能で確認できます。
*   **Draw.io (diagrams.net)**:
    *   イベントストーミングの結果 (`docs/requirements/eventstorming.drawio.svg`) など、より自由なレイアウトや表現が必要な図の作成・編集に使用します。
    *   `.drawio.svg` 形式で保存することで、SVGとして画像表示が可能でありながら、Draw.ioツールで再編集可能なデータを保持できます。
    *   **編集方法**: [diagrams.net](https://app.diagrams.net/) の Web サイト、または VSCode の [Draw.io Integration](https://marketplace.visualstudio.com/items?itemName=hediet.vscode-drawio) などの拡張機能を使用します。
    *   **Git管理**: `.drawio.svg` ファイルはテキストベース（XML）なので、Git で差分管理がある程度可能です。
    *   **共同編集**: Web サイト版ではリアルタイム共同編集も可能ですが、ファイルをローカルで編集し Git で管理する場合は、コンフリクトに注意が必要です。Pull Request 前に最新版を取得し、変更箇所が衝突しないように心がけます。
    *   Markdownへの埋め込み: `![代替テキスト](ファイルパス.drawio.svg)` の形式で Markdown ファイルに埋め込み、プレビューで表示できます。
*   **`cargo test`**: 実装したコードが仕様（テストケース）を満たしているかを確認します。コミット前には必ず実行します。
*   **`cargo fmt`**: コードスタイルを統一します。コミット前に実行します。
*   **`cargo clippy`**: 静的解析により、潜在的な問題や改善点を指摘します。定期的に実行します。
*   **`cargo doc`**: ソースコード中のドキュメントコメントからHTMLドキュメントを生成します。
*   **Git**: バージョン管理。コミットメッセージは **Conventional Commits** 規約に従います。
    *   **フォーマット**: `<type>(<scope>): <subject>`
        *   `type`: コミットの種類 (例: `feat`, `fix`, `docs`, `style`, `refactor`, `test`, `chore`)。
        *   `scope` (任意): コミットが影響する範囲 (例: `domain`, `application`, `readme`)。
        *   `subject`: 変更内容の簡潔な説明（**日本語で記述**）。50文字以内が目安。
    *   **例**:
        *   `feat(注文): 注文キャンセル機能を追加`
        *   `fix(domain): 価格計算時のオーバーフローを修正 (#123)`
        *   `docs: DEVELOPMENT_GUIDE にコミット規約を追記`
        *   `refactor: 注文サービスの依存性注入方法を変更`
        *   `test(application): 注文受付サービスのテストケースを追加`
    *   詳細は [Conventional Commits](https://www.conventionalcommits.org/) を参照してください。
    *   コミット前に `cargo fmt` を実行し、コードがフォーマットされていることを確認します。
