# イテレーション 2025-W21 バックログ

* **期間:** 2025-05-18 - 2025-05-24
* **ゴール:**
  1. ユーザーアカウント登録機能の基本的な画面仕様をStorybookで作成し、関連するバックエンドAPI（登録エンドポイント、OpenAPIスキーマ定義含む）を実装する。
  2. 作成したAPIを利用して、フロントエンドから基本的なユーザー登録処理（フォーム入力とAPI呼び出し）を実行できるようにする。

## タスクリスト (優先度順)

* **(計画時/各タスク開始前) ゴール確認とサブタスク分解:** 各タスクについて、目的・ゴールを明確にし、具体的なサブタスクに分解したか？
* [ ] `1. docs(ui): 認証関連画面 (トップページ、登録、ログイン) のStorybookでの仕様検討とコンポーネント作成、および画面フロー更新` *(Ref: docs/requirements/user_story_mapping.md#バックボーン-アカウント登録を行う, docs/ui/screen-flow.md)*
  * **ゴール:** ユーザー認証フローに必要な主要画面（トップページ(未ログイン時)、登録ページ、ログインページ）のUIコンポーネントをStorybookで作成し、画面の基本的なレイアウトと挙動を定義する。また、関連する画面フロー図 (`docs/ui/screen-flow.md`) を更新する。API連携はダミーデータで行う。
  * **スコープ:**
    * トップページ（未ログイン時）: 新規登録ボタン、ログインボタンの表示。
    * ユーザー登録フォーム: 主要項目（メールアドレス、パスワード、パスワード確認）、入力バリデーション、成功/エラー表示。
    * ログインフォーム: 主要項目（メールアドレス、パスワード）、成功/エラー表示。
    * `screen-flow.md` における認証関連画面の遷移フローの検討・図示。
  * **スコープ外:** 複雑なUIインタラクション、パスワードリセット等の補助機能。Storybook Interaction Testsの実装。
  * **サブタスク:**
    * [ ] 1.1. 認証関連画面（トップページ(未ログイン時)、登録、ログイン）のUIデザイン案を作成する（手書きスケッチや簡単なワイヤーフレームなど）。
    * [ ] 1.2. `docs/ui/screen-flow.md` を更新し、認証関連の画面フロー（例: 未ログイン時トップ → 登録画面 → ログイン画面、未ログイン時トップ → ログイン画面）を追記・図示する。
    * [ ] 1.3. 認証関連フォーム用のUIコンポーネント（例: `EmailInput`, `PasswordInput`, `SubmitButton`, `AuthPageLayout` など）を `frontend/src/components/features/Auth/` に作成し、Storybookで表示・調整する。
    * [ ] 1.4. トップページ（未ログイン時）のコンポーネント (`HomePageUnauthenticated.tsx` など) を作成し、Storybookで表示・調整する。
    * [ ] 1.5. ユーザー登録ページ全体のコンポーネント (`SignUpPage.tsx` など) を作成し、Storybookで表示・調整する（ダミーデータやモック関数を使用）。
    * [ ] 1.6. ログインページ全体のコンポーネント (`LoginPage.tsx` など) を作成し、Storybookで表示・調整する（ダミーデータやモック関数を使用）。
    * [ ] 1.7. バックエンドのドメイン設計 (Task2.1, 2.2) で定義される項目・バリデーションルール (メール形式、パスワードポリシー等) を考慮し、登録フォームおよびログインフォームのバリデーションロジックを検討・実装し、Storybookでエラー表示パターンを確認する。
    * [ ] 1.8. 認証処理の結果（成功時、失敗時）メッセージ表示コンポーネントを作成し、Storybookで確認する。
    * [ ] 1.9. 作成/変更したファイルをコミットし、リモートにプッシュする。
* [ ] `2. feat(backend): ユーザー登録APIの実装とOpenAPIスキーマ定義` *(Ref: docs/requirements/user_story_mapping.md#バックボーン-アカウント登録を行う)*
  * **ゴール:** ユーザー登録リクエストを受け付け、パスワードをハッシュ化してDBにユーザー情報を保存するAPIエンドポイントを作成する。OpenAPIスキーマを定義・更新する。ドメインロジックの堅牢性をテストで担保する。
  * **スコープ:** ユーザー登録処理（メールアドレス、ハッシュ化パスワードの保存）。ドメインレベルのバリデーション。基本的なエラーレスポンス。
  * **スコープ外:** メール認証、複雑なエラーハンドリング、ログインAPI。
  * **サブタスク:**
    * [ ] `2.1. docs(domain): ユーザーアカウントドメインの設計とテストケース定義`
      * `docs/domain/ubiquitous-language.md` を参照・更新し、「ユーザーアカウント」「メールアドレス」「パスワード」等の用語とルールを明確化する。
      * `ユーザーアカウント` (例: `RiyoushaAccount`) エンティティ、`メールアドレス` (例: `MailAddressValue`) VO、`ハッシュ化済みパスワード` (例: `HashSumiPasswordValue`) VO などを定義する (`docs/domain/domain-model.md` を更新/参照。具体的な命名は `docs/domain/ubiquitous-language.md` で行う)。
      * ユーザー登録時のドメインルール（例: メールアドレスの形式、パスワードの強度ポリシー）を定義する。
      * 上記エンティティ/VOの生成ロジック、バリデーションロジックに対するテストケースを洗い出す。
    * [ ] `2.2. feat(domain): ユーザーアカウントドメインの実装とテスト (テストファースト)`
      * `backend/src/domain.rs` (または関連モジュール) に サブタスク2.1で定義した `ユーザーアカウント` エンティティ、`メールアドレス` VO、`ハッシュ化済みパスワード` VO等を実装する。
      * パスワードハッシュ化のロジックを実装する (例: `argon2` クレート利用)。
      * サブタスク2.1で定義したテストケースに基づき、ドメインロジックのユニットテストを作成し、パスさせる (`#[test]`)。
    * [ ] `2.3. feat(domain): UserRepository トレイトの定義`
      * `backend/src/domain.rs` に `ユーザーリポジトリ` (例: `RiyoushaRepository`) トレイト（インターフェース）を定義する (例: `save(user: ユーザーアカウント型)`, `find_by_mail_address(mail: &メールアドレス型) -> Result<Option<ユーザーアカウント型>, ドメインエラー型>` など。型名は `docs/domain/ubiquitous-language.md` に従う)。
    * [ ] `2.4. feat(application): ユーザー登録ユースケースの実装とテスト (テストファースト)`
      * `backend/src/application.rs` に `ユーザー登録ユースケース` (例: `RiyoushaTourokuUseCase`) を実装する。
      * `ユーザーリポジトリ` トレイトのモック (`mockall` を使用) を作成する。
      * ユースケースの入力（登録情報DTO）、出力（成功/エラー）を定義する。
      * ユースケースのテストを作成し（リポジトリの呼び出し検証、ドメインロジックの呼び出し検証など）、パスさせる。
    * [ ] `2.5. feat(infrastructure): UserRepository の実装 (PostgreSQL)`
      * `backend/src/infrastructure.rs` に `Pgユーザーリポジトリ` (例: `PgRiyoushaRepository`) を実装する。
      * `users` テーブルのスキーマを設計し、マイグレーションファイルを作成・適用する (`docs/db/schema.sql` と `docs/db/er-diagram.md` も更新)。
      * (任意だが推奨) `Pgユーザーリポジトリ` に対する結合テストを作成し、実際のDBコンテナと連携して動作確認する。
    * [ ] `2.6. feat(api): ユーザー登録APIエンドポイントの実装とOpenAPI定義`
      * `backend/src/main.rs` (または `routes` モジュール) に `/users` (または `/auth/register`) エンドポイントを実装する (`axum` を使用)。
      * APIリクエスト/レスポンス用のDTOを定義する。
      * エンドポイントからアプリケーション層の `RegisterUserUseCase` を呼び出す。
      * `utoipa` を用いてOpenAPIスキーマ定義を更新・生成する。
      * 手動または `reqwest` などで簡単なAPI動作確認を行う。
    * [ ] `2.7. docs(backend): バックエンド関連ドキュメントの更新`
      * `README.md` や `docs/PRODUCT_DEVELOPMENT_GUIDE.md` など、必要に応じてバックエンドの構造やテスト方法に関する記述を更新する。
    * [ ] `2.8. chore(git): 作成/変更したファイルをコミットし、リモートにプッシュする`
* [ ] `3. feat(frontend): ユーザー登録機能のフロントエンド実装（API連携）` *(Ref: Task 1, Task 2)*
  * **ゴール:** Storybookで作成した登録画面コンポーネントと、バックエンドで作成した登録APIを連携させ、実際にユーザー登録処理を実行できるようにする。
  * **スコープ:** フォーム入力値をAPIリクエストとして送信。APIレスポンスに基づいた画面表示（成功メッセージ、エラーメッセージ）。React Query等を用いた状態管理の基本設定。
  * **スコープ外:** ログイン機能、セッション管理。
  * **サブタスク:**
    * [ ] `3.1. feat(frontend/api): ユーザー登録APIクライアント関数の実装と型定義`
      * バックエンドのOpenAPIスキーマ (Task2.6で定義) から生成されたAPIクライアント (`openapi-typescript-codegen` 等) を利用、または手動で、ユーザー登録APIを呼び出すための関数を作成する (`frontend/src/lib/api/auth.ts` など)。
      * APIリクエストとレスポンスの型定義を確認・利用する。
    * [ ] `3.2. feat(frontend/hook): ユーザー登録処理を行うカスタムフックの作成とテスト (テストファースト)`
      * ユーザー登録フォームの入力値を引数に取り、Task3.1で作成したAPIクライアント関数を呼び出して登録処理を行うカスタムフック (例: `useRegisterUser`) を作成する (`frontend/src/hooks/features/Auth/useRegisterUser.ts` など)。
      * React Query (`useMutation` など) を利用して、API呼び出しのローディング状態、成功/失敗状態、エラー情報などを管理する。
      * APIクライアント関数をモック化し、カスタムフックの以下の点をテストする (Vitest + RTL):
        * フォーム入力値が正しくAPIクライアント関数に渡されること。
        * API成功時に、適切な状態（例: `isSuccess`）が返されること。
        * API失敗時に、エラー情報（例: `error` オブジェクト）が正しく処理され、返されること。
        * ローディング状態 (`isLoading`) が適切に遷移すること。
    * [ ] `3.3. feat(frontend/ui): 登録ページコンポーネントとカスタムフックの連携および画面遷移`
      * Task1で作成したユーザー登録ページコンポーネント (`SignUpPage.tsx` など) に、Task3.2で作成した `useRegisterUser` フックを組み込む。
      * フォームの送信イベントでフックの登録関数を呼び出すようにする。
      * フックから返されるローディング状態、成功/エラー状態に応じて、UI表示（例: ローディングスピナー、成功メッセージ、エラーメッセージ）を切り替える。
      * 登録成功時には、ログインページ（または適切な次のページ）へ画面遷移する処理を実装する。
    * [ ] `3.4. test(frontend/ui): 登録ページコンポーネントのAPI連携部分テスト (モックAPI)`
      * `useRegisterUser` フック (またはそれが依存するAPIクライアント) をモック化し、登録ページコンポーネントが以下の挙動をすることを確認する (Vitest + RTL):
        * フォーム入力・送信時に、モック化された登録関数が適切な引数で呼び出されること。
        * モックが成功を返した場合、成功メッセージが表示されること。
        * モックがエラーを返した場合、エラーメッセージが表示されること。
        * 登録処理中にローディング表示がされること。
    * [ ] `3.5. docs(frontend): フロントエンド関連ドキュメント更新と動作確認`
      * 必要に応じて `frontend/README.md` 等を更新する。
      * 開発環境で実際にバックエンドAPIと連携させ、ユーザー登録が一通り動作することを確認する（手動テスト）。
    * [ ] `3.6. chore(git): 作成/変更したファイルをコミットし、リモートにプッシュする`

## イテレーション間活動記録 (任意)

* (前のイテレーション終了後、今回の計画開始までに実施したこと。例: 技術タスク消化、ドキュメント整理、学習など)

---

*(イテレーション完了時に以下を確認・記入)*
---

## レビューまとめ

* **イテレーションゴール達成度:** (達成 / 一部達成 / 未達)
  * 目標: (計画時のゴールを再掲)
  * 結果: (達成状況を具体的に記述)
* **完了した主要タスク/成果物:**
  * (完了したタスクリストNo. や主要な成果物を記載)
* **特記事項・次への影響:**
  * (予定外の作業、発生した課題、次のイテレーションへの申し送り事項など)

## イテレーション完了時チェックリスト

* [ ] **技術タスク同期:** イテレーション中に発生/完了した技術タスクは `docs/technical_tasks.md` に反映したか？
* [ ] **ドメイン知識同期:**
  * [ ] 新しい用語や定義、ルールの変更は `docs/domain/ubiquitous-language.md` に反映したか？
  * [ ] ドメインモデルの構造に変更はあったか？ あれば `docs/domain/domain-model.md` に反映したか？
* [ ] **その他ドキュメント同期:**
  * [ ] プロジェクト概要や使い方に変更はあったか？ あれば `README.md` に反映したか？
  * [ ] 開発プロセスやガイドラインに変更はあったか？ あれば関連ドキュメント (`docs/process/`, `docs/PRODUCT_DEVELOPMENT_GUIDE.md` など) に反映したか？
  * [ ] プロダクト定義 (`docs/product/`) や要求定義 (`docs/requirements/`) に影響する変更はなかったか？ (あれば更新 or 次期タスク化)
* [ ] **ADR同期:** 新たなアーキテクチャ決定は ADR (`docs/architecture/adr/`) として記録したか？
* [ ] **DBスキーマ同期:** (DB変更があった場合) `docs/db/schema.sql` 及び `docs/db/er-diagram.md` は最新の状態か？ マイグレーションファイルは作成/適用済みか？
* [ ] **AIアシスタントルールレビュー:** AIアシスタントのルール (`@rules` や `.cursor/rules/` 内ファイル) に変更や追加の必要性がないか確認したか？ (必要であればAIにレビューを依頼)

## 振り返り (Retrospective)

* **Keep (良かったこと):**
  * [ ]
* **Problem (問題点・課題):**
  * [ ]
* **Try (次に試すこと):**
  * [ ]
* **戦略への示唆 (任意):**
  * [ ] 今回の学びや課題から、プロダクト戦略/ロードマップ (`docs/product/`) の見直しに繋がりそうな点はあったか？ (あれば戦略レビューのインプット候補)
  * [ ] 次回の戦略レビューに向けて、意識的に収集・観察すべきデータやユーザーの声は何か？
